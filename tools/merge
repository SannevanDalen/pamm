#!/usr/bin/python
from numpy import *
from scipy.sparse.csgraph import connected_components
from scipy.misc import factorial
import sys

verbose = False  # no verbosity
saveadj = False  # don't store adjacency
savegrd = False  # don't store macrogrid
savebrd = False  # don't store boarder points
savegrp = False  # don't store gabriel graph
errflag = False  # don't use errors
logflag = True   # logarithm of probabilities as input
thresh  = 0.9    # threshold to merge cluster
D       = -1     # dimensionality needs to be specified

if len(sys.argv) < 2:
  print "usage: merge -D dim [-t tresh] [-e] [-l] [-adj] [-m] [-b] [-g] [-v] [-h] grid"
  sys.exit("ERROR: no grid file specified")
else:
  for i,s in enumerate(sys.argv):
    if   s == '-D'   : D       = int(sys.argv[i+1])
    elif s == '-t'   : thresh  = float(sys.argv[i+1])
    elif s == '-err' : errflag = True
    elif s == '-log' : logflag = False
    elif s == '-adj' : saveadj = True
    elif s == '-m'   : savegrd = True
    elif s == '-b'   : savebrd = True
    elif s == '-g'   : savegrp = True
    elif s == '-v'   : verbose = True
    elif s == '-h'   : 
      print """
usage: merge -D dim [-t tresh] [-e] [-l] [-adj] [-m] [-b] [-g] [-v] [-h] grid"

 required:
 
   -D dim        : dimensionality
   grid          : pamm grid file
       
 optional:

   -t thresh     : threshold to merge cluster                   [0.9]
   -err          : use error of KDE in adjacency                [false]
   -log          : use logarithm of probabilities               [true]
   -adj          : write out adjacency matrix                   [false]
   -m            : write out gridfile containing                [false]
                   new macrogrid              
   -b            : write out boarder points                     [false]
   -g            : write out gapriel graph connecting points    [false]
   -v            : turn verbosity on                            [false]
   -h            : show this message
      """
      sys.exit()

print """ 
 ****************************************** 
 *                                        * 
 *               PAMM Tools               * 
 *                                        * 
 ****************************************** 
                                               
 cluster merging based on:                  
   - gabriel neighbors                      
   - adjacency criterion                    
   - errors (not implemented yet)           
   - true log-sum-exp                       
                                            
 Version: 1.0                               
 Date   : 02/17/17                          
 Author : robert.meissner@epfl.ch                                                           
"""   

#######################################################################
###                                                                 ###
###                          input control                          ###
###                                                                 ###
#######################################################################

if D < 0: sys.exit("ERROR: no dimension specified")

try:
    with open(sys.argv[-1]) as file:
        pass
except IOError as e:
    print "ERROR: Unable to open file"
gridfile = sys.argv[-1]

# define output names
if gridfile[-5:] == '.grid': basename = gridfile[:-5] 
else : basename = gridfile
mgridfile = basename + '.mgrid'
macrofile = basename + '.macro'
adjfile   = basename + '.adj'
brdfile   = basename + '.boarders'
neighfile = basename + '.neigh'

# load data
data = loadtxt(gridfile)

X    = data[:,:D]
cid  = array(map(int,data[:,D]))
prob = data[:,D+1]

N  = X.shape[0]
Nc = len(unique(cid))
uc = unique(cid)

# output every this many steps if looped over cluster
multi = round(log10(Nc))-1
if multi < 1: multi = 0
csteps = 10**multi

# output every this many steps if looped over grid
multi = round(log10(N))-1
if multi < 1: multi = 0
# multiplier whenever something over a grid is calculated
steps = 10**multi

# prepare adjacency matrix skeleton
if logflag: 
  thresh = log(thresh)
  adj = ones([Nc,Nc])*-inf
else:
  adj = zeros([Nc,Nc])


#######################################################################
###                                                                 ###
###                          main program                           ###
###                                                                 ###
#######################################################################

if verbose: print " Compute Distance Matrix"
# we need squared distances for gabriel graph
distsq = zeros([N,N])
for i,xi in enumerate(X):
    # matrix is symmetric, loop over upper triangular
    distsq[i,:] = linalg.norm(xi-X,axis=1)**2
    
    # distance to myself is far away
    distsq[i,i] = inf
  
    if verbose and (mod(i+1,steps)==0): print "  %d / %d" % (i+1,N)


neighs = zeros([N,N], dtype=bool)
#if verbose: print " Finding connections between clusters"
#for ic,c in enumerate(uc):   
#    for i,x in enumerate(X):
#        # loop over points in my cluster
#        if c != cid[i]: continue
#        mindist = inf
#        jmin = -1
#        for j,y in enumerate(X):
#            # check if we are in same cluster
#            if c == cid[j]: continue
#            if distsq[i,j] < mindist:
#                mindist = distsq[i,j]
#                jmin = j
#        if jmin > -1: neighs[i,jmin] = 1
#    if verbose and (mod(ic+1,steps)==0): print "  %d / %d" % (ic+1,Nc)

if verbose: print " Loading Gabriel Graph"
with open(neighfile) as gf:
    for i,line in enumerate(gf):
        line = line.replace('F','0')
        line = line.replace('T','1')
        neighs[i,:] = array(map(int,line.split()),dtype=bool)
        if verbose and (mod(i+1,steps)==0): print "  %d / %d" % (i+1,N)
#if verbose: print " Building Gabriel Graph"
## find gabriel neighbors of i
#for i in range(N):
#    # matrix is symmetric, loop over upper triangular
#    for j in range(i):        
#        # if i and j are in the same cluster skip operation
#        if cid[i] == cid[j]: continue
#        
#        flag = distsq[i,j] >= (distsq[i,:] + distsq[j,:])
#        
#        if not flag.any():     
#          neighs[i,j] = True
#          # matrix is symmetric
#          neighs[j,i] = True

#    if verbose and (mod(i+1,steps)==0): print "  %d / %d" % (i+1,N)
    
    
if verbose: print " Building adjacency matrix"
# create array to store border points
brd = zeros(N,dtype=bool)
# loop over all cluster
for i in range(N):
    # max prob of cluster ci
    maxPci = max(prob[cid==cid[i]])
    for j in range(N):
        # are i and j in two different clusters?
        if cid[i] == cid[j]: continue
        
        # cluster ci and cj are connected if points i and j are gabriel neighbors
        if neighs[i,j]:
            # mark points as boarder points
            brd[i] = True
            brd[j] = True
        
            # max prob of cluster cj
            maxPcj = max(prob[cid==cid[j]])
            
            # store highest adjacency between cluster 
            if logflag:
                # use micheles log-approximation for sums
                if prob[i] > prob[j]: avgP = prob[i] + log(1.+exp(prob[j]-prob[i]))
                else:                 avgP = prob[j] + log(1.+exp(prob[i]-prob[j]))
                tmp = avgP - min(maxPci,maxPcj) - log(2)
                
                if tmp > adj[uc==cid[i],uc==cid[j]] : adj[uc==cid[i],uc==cid[j]] = tmp
            else:
                # straightforward adjacency without log-exp-prob
                tmp = (prob[i]+prob[j])/(2.*min(maxPci,maxPcj))
                
                if tmp > adj[uc==cid[i],uc==cid[j]] : adj[uc==cid[i],uc==cid[j]] = tmp
              
    if verbose and (mod(i+1,steps)==0): print "  %d / %d" % (i+1,N)


# rescale adjacency matrix to identify connected nodes
if verbose: print " Finding macrocluster"
# create boolean adjacency matrix
adj_bool = zeros([Nc,Nc],dtype=bool)

# at this point I made an error: 
# we merge here clusters which are actually not connected
# due to their common connection to a lower probable cluster
# adj_bool[where(adj >  thresh)] = 1

for i in range(Nc):
  # is there an adjacent cluster
  if sum(adj[i,:]) == 0: continue
  # connect to cluster with highest adjacency
  j = argmax(adj[i,:])
  if adj[i,j] > thresh: adj_bool[i,j] = True

# get macrocluster ids
Nm, m = connected_components(adj_bool)

#######################################################################
###                                                                 ###
###                       output of program                         ###
###                                                                 ###
#######################################################################    

if verbose: print " Write out"

# write gabriel graph to file if desired
#if savegrp: savetxt(neighfile,neighs,header="gabriel graph",fmt='%d')
    
# write adjacency matrix to file if desired 
if saveadj: 
  if logflag: savetxt(adjfile,adj,header="adjacency matrix (log-scaled)") 
  else:       savetxt(adjfile,adj,header="adjacency matrix")              

# write out macrogrid file and boarder points if desired 
if savegrd: 
  fout = open(mgridfile,'w')
  with open(gridfile) as fin:
    i = 0
    for line in fin:
      # skip comments
      if '#' in line: continue
      # convert cluster from grid to macrocluster and write out
      data = map(float,line.split()) 
      data[D] = m[int(data[D])-1]+1
      # append flag to identify boarder points if desired
      if savebrd: 
        if brd[i]: b = 1
        else: b = 0
        data.append(b)
        i = i+1
      fout.write(' '.join(map(str,data))+'\n')
  fout.close()
      
# write out cluster association to macrocluster
f = open(macrofile,'w')
f.write("# cluster macrocluster adjacency\n")
for i,c in enumerate(uc):
  f.write("%d %d\n" % (c,m[i]+1))
f.close()
