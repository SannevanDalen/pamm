#!/usr/bin/python
from numpy import *
from scipy.sparse.csgraph import connected_components
from scipy.misc import factorial
import sys

verbose = False  # no verbosity
saveadj = False  # don't store adjacency
savegrd = False  # don't store macrogrid
savebrd = False  # don't store boarder points
errflag = False  # don't use errors
logflag = True   # logarithm of probabilities as input
thresh  = 0.9    # threshold to merge cluster
D       = -1     # dimensionality needs to be specified

if len(sys.argv) < 2:
  print "usage: merge -d dim [-t tresh] [-e] [-l] [-adj] [-m] [-b] [-v] [-h] grid"
  sys.exit("ERROR: no grid file specified")
else:
  for i,s in enumerate(sys.argv):
    if   s == '-d'   : D       = int(sys.argv[i+1])
    elif s == '-t'   : thresh  = float(sys.argv[i+1])
    elif s == '-e '  : errflag = True
    elif s == '-l'   : logflag = False
    elif s == '-adj' : saveadj = True
    elif s == '-m'   : savegrd = True
    elif s == '-b'   : savebrd = True
    elif s == '-v'   : verbose = True
    elif s == '-h'   : 
      print "usage: merge -d dim [-t tresh] [-e] [-l] [-adj] [-m] [-b] [-v] [-h] grid"
      print " "
      print " -d dim        : dimensionality"
      print " "
      print " -t thresh     : threshold to merge cluster [0.9]"
      print " "
      print " -e            : use error of KDE in adjacency [false]"
      print " "
      print " -l            : use logarithm of probabilities [true]"
      print " "
      print " -adj          : write out adjacency matrix [false]"
      print " "
      print " -m            : write out gridfile containing"
      print "                 new macrogrid [false]"
      print " "
      print " -b            : write out boarder points"
      print " "
      print " -v            : turn verbosity on [false]"
      print " "
      print " -h            : show this message"
      sys.exit()

print "                                            " 
print " ****************************************** "
print " *                                        * "
print " *               PAMM Tools               * "
print " *                                        * "
print " ****************************************** "
print "                                            "   
print " cluster merging based on:                  "
print "   - gabriel neighbors                      "
print "   - adjacency criterion                    "
print "   - errors (not implemented yet)           "
print "   - true log-sum-exp                       "
print "                                            "
print " Version: 1.0                               "
print " Date   : 02/17/17                          "
print " Author : robert.meissner@epfl.ch           "
print "                                            "    
print "                                            "    

#######################################################################
###                                                                 ###
###                          input control                          ###
###                                                                 ###
#######################################################################

if D < 0: sys.exit("ERROR: no dimension specified")

try:
    with open(sys.argv[-1]) as file:
        pass
except IOError as e:
    print "ERROR: Unable to open file"
gridfile = sys.argv[-1]

# define output names
if gridfile[-5:] == '.grid': basename = gridfile[:-5] 
else : basename = gridfile
mgridfile = basename + '.mgrid'
macrofile = basename + '.macro'
adjfile   = basename + '.adj'
brdfile   = basename + '.boarders'

# load data
data = loadtxt(gridfile)

X    = data[:,:D]
cid  = array(map(int,data[:,D]))
prob = data[:,D+1]

N  = X.shape[0]
Nc = len(unique(cid))
uc = unique(cid)

# output every this many steps if looped over cluster
multi = round(log10(Nc))-1
if multi < 1: multi = 0
csteps = 10**multi

# output every this many steps if looped over grid
multi = round(log10(N))-1
if multi < 1: multi = 0
gsteps = 10**multi

# prepare adjacency matrix skeleton
if logflag: 
  thresh = log(thresh)
  adj = ones([Nc,Nc])*-inf
else:
  adj = zeros([Nc,Nc])


#######################################################################
###                                                                 ###
###                          main program                           ###
###                                                                 ###
#######################################################################

if verbose: print " Compute Distance Matrix"
# we need squared distances for gabriel graph
distsq = zeros([N,N])
for i,xi in enumerate(X):
    # matrix is symmetric, loop over upper triangular
    distsq[i,:] = linalg.norm(xi-X,axis=1)**2
    
    # distance to myself is far away
    distsq[i,i] = inf
  
    if verbose and (mod(i+1,gsteps)==0): print "  %d / %d" % (i+1,N)


if verbose: print " Building Gabriel Graph"
# find gabriel neighbors of i
gneighs = zeros([N,N], dtype=bool)
for i in range(N):
    # matrix is symmetric, loop over upper triangular
    for j in range(i-1):        
        # if i and j are in the same cluster skip operation
        if cid[i] == cid[j]: continue
        
        flag = distsq[i,j] > distsq[i,:] + distsq[j,:]
        
        if not flag.any():     
          gneighs[i,j] = True
          # matrix is symmetric
          gneighs[j,i] = True

    if verbose and (mod(i+1,gsteps)==0): print "  %d / %d" % (i+1,N)
    

if verbose: print " Building adjacency matrix"
# create array to store border points
brd = zeros(N,dtype=bool)
# loop over all cluster
for i in range(N):
    # max prob of cluster ci
    maxPci = max(prob[cid==cid[i]])
    for j in range(N):
        # are i and j in two different clusters?
        if cid[i] == cid[j]: continue
        
        # cluster ci and cj are connected if points i and j are gabriel neighbors
        if gneighs[i,j]:
            # max prob of cluster cj
            maxPcj = max(prob[cid==cid[j]])
            
            # mark points as boarder points
            brd[i] = True
            brd[j] = True
            # store highest adjacency between cluster 
            if logflag:
                # use micheles log-approximation for sums
                if prob[i] > prob[j]: avgP = prob[i] + log(1.+exp(prob[j]-prob[i]))
                else:                 avgP = prob[j] + log(1.+exp(prob[i]-prob[j]))
                tmp = avgP - min(maxPci,maxPcj) - log(2)
                
                if tmp > adj[uc==cid[i],uc==cid[j]] : adj[uc==cid[i],uc==cid[j]] = tmp
            else:
                # straightforward adjacency
                tmp = (prob[i]+prob[j])/(2.*min(maxPci,maxPcj))
                
                if tmp > adj[uc==cid[i],uc==cid[j]] : adj[uc==cid[i],uc==cid[j]] = tmp
              
    if verbose and (mod(i+1,gsteps)==0): print "  %d / %d" % (i+1,N)

# rescale adjacency matrix to identify connected nodes
if verbose: print " Finding macrocluster"
# create boolean adjacency matrix
adj_bool = zeros([Nc,Nc])
adj_bool[where(adj >  thresh)] = 1
# get macrocluster ids
Nm, m = connected_components(adj_bool)

#######################################################################
###                                                                 ###
###                       output of program                         ###
###                                                                 ###
#######################################################################    

if verbose: print " Write out"
    
# write adjacency matrix to file if desired 
if saveadj: 
  if logflag: savetxt(adjfile,adj,header="adjacency matrix (log-scaled)") 
  else:       savetxt(adjfile,adj,header="adjacency matrix")              

# write out macrogrid file and boarder points if desired 
if savegrd: 
  fout = open(mgridfile,'w')
  with open(gridfile) as fin:
    i = 0
    for line in fin:
      # skip comments
      if '#' in line: continue
      # convert cluster from grid to macrocluster and write out
      data = map(float,line.split()) 
      data[D] = m[int(data[D])-1]+1
      # append flag to identify boarder points if desired
      if savebrd: 
        if brd[i]: b = 1
        else: b = 0
        data.append(b)
        i = i+1
      fout.write(' '.join(map(str,data))+'\n')
  fout.close()
      
# write out cluster association to macrocluster
f = open(macrofile,'w')
f.write("# cluster macrocluster\n")
for i,c in enumerate(uc):
  f.write("%d %d\n" % (c,m[i]+1))
f.close()
