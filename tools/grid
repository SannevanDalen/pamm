#!/usr/bin/python
from numpy import *
from scipy.special import gamma
import sys

verbose = False  # no verbosity
N       = -1     # grid size equals sample size
outfile = []     # use input data file as basename for outpur
rndflag = False  # use minmax
gamma   = -1     # no staged grid selection
metric  = 0      # use minkoswki metric 
norm    = 2      # use euclidean distances

if len(sys.argv) < 1:
  print "usage: grid [-n N] [-o name] [-rand] [-s gamma] [-m mode] [-p norm] [-v] [-h] data"
  sys.exit("ERROR: no data file specified")
else:
  for i,s in enumerate(sys.argv):
    if   s == '-n'      : N       = int(sys.argv[i+1])
    if   s == '-o'      : outfile = sys.argv[i+1]
    if   s == '-rand'   : rndflag = True
    if   s == '-s'      : gamma   = float(sys.argv[i+1])
    if   s == '-m'      : metric  = int(sys.argv[i+1])
    if   s == '-p'      : norm    = float(sys.argv[i+1])
    elif s == '-v'      : verbose = True
    elif s == '-h'      : 
      print """
usage: grid [-n N] [-o name] [-rand] [-s gamma] [-m mode] [-p norm] [-v] [-h] data
 
 required: 
  
   data          : input data
   
 optional:

   -n N          : grid size                                    [all]
   -o name       : filename of grid                             [data + .idxs]
   -rand         : random selection of grid points              [false]
   -s gamma      : mixed mode between selecting grid points via [false]
                   minmax and random selection. Within each 
                   voronoi a random selection of grid points is
                   made. gamma defines fraction of points 
                   selected by each method gamma=0 is pure 
                   random and gamma=1 is pure minmax selection. 
   -m mode       : metric mode                                  [0]
                   0   - minkowski
                   1   - cosine 
                   2   - global mahalanobis
                   3   - local mahalanobis (experimental)
   -p norm       : norm of the minkowski metric                 [2]
                   1   - manhattan
                   2   - euclidean
                   < 1 - fractional
   -v            : turn verbosity on                            [false]
   -h            : show this message"""
      sys.exit()

print """ 
 ****************************************** 
 *                                        * 
 *               PAMM Tools               * 
 *                                        * 
 ****************************************** 
                                               
 grid creation based on:                    
   - minmax criterion (default)             
     or random points     
     or mix between both                  
   - euclidean distance (default)              
     or cosine distance
     or minkowski distance      
     or mahalanobis distance 
   - periodic boundary conditions (not implemented)          
                                            
 Version: 1.0                               
 Date   : 03/08/17                          
 Author : robert.meissner@epfl.ch 
"""    

#######################################################################
###                                                                 ###
###                       function definitions                      ###
###                                                                 ###
#######################################################################

def mm(x,idxs,n=-1,met=0,norm=2.,verbose=False,steps=10):
  "creates grid points using minmax criterion"

  # estimate true covariance from "all" points
  if met==2: Qinv = linalg.inv(cov(x.T))

  # if n not set
  if n < 0: n = int(x.shape[0]**(1.0/2.0))
  x = array(x)[idxs]
  d = 1
  if (x.ndim > 1): d = x.shape[1]
  y = empty((n,d))
  x = x.reshape(-1,d)

  dmin = ones(x.shape[0])*inf

  # choosing a random point
  iy = random.randint(0,x.shape[0])
  y[0,:] = x[iy,:]
  # add point to new grid
  igrid = [idxs[iy]]

  for i in range(1,n):

    if verbose and (mod(i+1,steps)==0): 
      print "   %d/%d" % (i+1,n)
     
    # distance metric definition  
    if   met==1:
      dx = 1. - sum(x*y[i-1,:],axis=1)    \
              / ( linalg.norm(x,axis=1)   \
              *   linalg.norm(y[i-1,:]) )
    elif met==2: 
      dx = sqrt(sum((x-y[i-1,:])*matmul(x-y[i-1,:],Qinv),axis=1))
    elif met==3: 
      # use local information to estimate the covariance
      dist = linalg.norm(x-y[i-1,:],axis=1)
      V = pi**(d/2.)/gamma(d/2. + 1.)*dist**d
      w = dist/V
      w[i-1] = max(w[~isnan(w)])
      Q = cov(x.T,aweights=w)
      # oracle shrinkage of Q to avoid singular matrices
      Q = oracle(Q,X.shape[0])
      # invert matrix
      Qinv = linalg.inv(Q)
      dx = sqrt(sum((x-y[i-1,:])*matmul(x-y[i-1,:],Qinv),axis=1))
    else: 
      dx = (sum(abs(x-y[i-1,:])**norm,axis=1))**(1./norm)
     
    dmin[dmin > dx] = dx[dmin > dx]
    iy = argmax(dmin)
    y[i,:] = x[iy,:]
    igrid.append(idxs[iy])
  return y,igrid
  
def vlist(X,idxs):
  """
    assigns sample points to closest voronoi and gives back
    a list of indices where each sample point is associated
    to the appropriate voronoi.
  """
  
  n = X.shape[0]
  d = 1
  if (X.ndim > 1): d = X.shape[1]
  X = X.reshape(-1,d)

  Y = X[idxs,:]
  
  # create array associating sample points to grid points
  vlist = empty(n)
  for i,x in enumerate(X):
    dx = linalg.norm(Y-x,axis=1)
    # get index of closest distance
    vlist[i] = idxs[argmin(dx)]
  vlist = array(map(int,vlist))
  return vlist   
  
def oracle(Q,N):
  "oracle shrinkage of matrix"
  
  if len(Q.shape) < 2: D = 1.
  else: D = float(Q.shape[1])
  
  # apply oracle approximating shrinkage alogorithm on local Q
  a = ( (1.-2./D) * trace(Q**2) \
         + trace(Q)**2 ) / ( (N + 1. - 2./D) \
         * trace(Q**2) \
         - (trace(Q)**2.) / D )
      
  b = min(1.,a)
        
  # regularized local covariance matrix for grid point 
  Qr = (1.-b)*Q + b*trace(Q)*identity(int(D)) / D
  
  return Qr

#######################################################################
###                                                                 ###
###                          input control                          ###
###                                                                 ###
#######################################################################

try:
    with open(sys.argv[-1]) as file:
        pass
except IOError as e:
    print "ERROR: unable to open data file"
datafile = sys.argv[-1]

X = loadtxt(datafile)

if not outfile: outfile = datafile + '.idxs'

if rndflag and (gamma > 0): sys.exit("ERROR: random or staged selection?")

#######################################################################
###                                                                 ###
###                          main program                           ###
###                                                                 ###
#######################################################################

# check for duplicate entries and get only indexes of unique points
if verbose:  print " analyzing input ..."
_,idxs = unique(map(str,X),return_index=True)

if N < 0: N = idxs.shape[0]
if N>idxs.shape[0]: sys.exit("ERROR: grid size too big")

# output every this many steps if looped over grid
multi = round(log10(N))-1
if multi < 1: multi = 0
if multi > 4: multi = 4
# multiplier whenever something over a grid is calculated
steps = 10**multi

if rndflag:
  if verbose: print " selecting %d random points ..." % N
  random.shuffle(idxs)
  idxs = idxs[:N]
if gamma > 0:
  Nmm  = int(N*gamma)
  Nrnd = N-Nmm  
  
  if verbose: print " (i) selecting %d points using minmax ..." % Nmm
  _,idxs = mm(X,idxs,Nmm,metric,norm,verbose,steps)
  
  if verbose: print " (ii) selecting %d random points in voronois ..." % Nrnd
  s2g = vlist(X,idxs) # sample to grid 
  for i in range(Nrnd):
    # select random grid point
    gi = idxs[random.randint(Nmm)]
    # select a random point within voronoi
    rnd_idxs = where(s2g == gi)[0]
    idxs.append(rnd_idxs[random.randint(len(rnd_idxs))])
    if verbose and (mod(i+1,steps)==0): 
      print "   %d/%d" % (i+1,Nrnd)
else:
  if verbose: print " selecting %d points using minmax ..." % N
  _,idxs = mm(X,idxs,N,metric,norm,verbose,steps)

#######################################################################
###                                                                 ###
###                       output of program                         ###
###                                                                 ###
#######################################################################  

if verbose:  print " writing grid ..."
# store indexes in PAMM format and not in python format
savetxt(outfile,array(idxs)+1,fmt='%d')
