#!/usr/bin/python
# multivariate bayesian bandwidth estimation

from numpy import *
from matplotlib import cm
from scipy.misc import logsumexp
from scipy.spatial import ConvexHull

from matplotlib.patches import Polygon

import matplotlib.pyplot as P
import sys

D       = -1
verbose = False  # no verbosity
d       = 2      # use two-dimensional projection
nplot   = -1     # show all cluster
minsize = 1      # show cluster with one member
flip    = False  # plot cluster from low to high probable
pflag   = False  # no print out of probabilities
cvxflag = False  # do not use convex hull to illustrate cluster
smode   = 0      # sort cluster according to size
lo      = nan    # use min/max of probability as limits for prob plot
hi      = nan    # use min/max of probability as limits for prob plot

if len(sys.argv) < 5:
  print "usage: pamm2prj -D dim [-d dim] [-min min] [-n N] [-flip] [-sort mode] [-p] [-hull] [-lo lo] [-hi hi] [-v] [-h] grid proj idxs"
  sys.exit("ERROR: not enough input provided")
else:
  for i,s in enumerate(sys.argv):
    if   s == '-D'    : D       = int(sys.argv[i+1])
    elif s == '-d'    : d       = int(sys.argv[i+1])
    elif s == '-min'  : minsize = int(sys.argv[i+1])
    elif s == '-n'    : nplot   = int(sys.argv[i+1])
    elif s == '-flip' : flip    = True
    elif s == '-sort' : smode   = int(sys.argv[i+1])
    elif s == '-p'    : pflag   = True
    elif s == '-hull' : cvxflag = True
    elif s == '-lo'   : lo      = float(sys.argv[i+1])
    elif s == '-hi'   : hi      = float(sys.argv[i+1])
    elif s == '-v'    : verbose = True
    elif s == '-h'    : 
      print """
usage: pamm2prj -D dim [-d dim] [-min min] [-n N] [-flip] [-sort mode] [-p] [-hull] [-lo lo] [-hi hi] [-v] [-h] grid proj idxs"

 required:
   
   -D dim        : dimensionality of data 
   grid          : pamm grid file
   proj          : projection of data (pca, sketchmap or ...)
   idxs          : association to projection
 
 optional
  
   -d dim        : dimensionality of projection       [2]
   -min min      : minimum size of cluster to plot    [1]
   -n N          : plot only N cluster                [all]
   -flip         : flip sorting                       [false]
   -sort mode    : sort mode                          [0]
                   0   - points in cluster
                   1   - kernel density fraction
   -hull         : use convex hull of cluster         [false]
   -p            : plot probabilities on sketchmap    [false]
   -lo lo        : lower limit for probability plot   [min(prob)]
   -hi hi        : upper limit for probability plot   [max(prob)]
   -v            : turn verbosity on                  [false]
   -h            : show this message
      """
      sys.exit()

print """ 
 ****************************************** 
 *                                        * 
 *               PAMM Tools               * 
 *                                        * 
 ****************************************** 
                                              
 plot results of PAMM on projection         
                                            
 Version: 1.0                               
 Date   : 21/03/17                          
 Author : robert.meissner@epfl.ch                                                          
"""   

#######################################################################
###                                                                 ###
###                          input control                          ###
###                                                                 ###
#######################################################################

if D < 0: sys.exit("ERROR: no dimension specified")
if d > 2: sys.exit("ERROR: can't plot more than two dimensions")

# try to open input files
try:
    with open(sys.argv[-3]) as file:
        pass
except IOError as e:
    sys.exit("ERROR: Unable to open grid file")
gridfile = sys.argv[-3]
try:
    with open(sys.argv[-2]) as file:
        pass
except IOError as e:
    sys.exit("ERROR: Unable to open proj file")
projfile = sys.argv[-2]
try:
    with open(sys.argv[-1]) as file:
        pass
except IOError as e:
    sys.exit("ERROR: Unable to open idxs file")
idxsfile = sys.argv[-1]

#######################################################################
###                                                                 ###
###                          main program                           ###
###                                                                 ###
#######################################################################

idxs = loadtxt(idxsfile,dtype=int)
smap = loadtxt(projfile)
pamm = loadtxt(gridfile)
if len(idxs) > len(pamm):
  smap = smap[idxs-1,:2]

N = pamm.shape[0]

X     = smap[:N,:d]
cls   = pamm[:,D]
p     = pamm[:,D+1]
wgrid = pamm[:,D+6]

if isnan(lo):
  lo = min(p)
if isnan(hi):
  hi = max(p)
  
# get unique cluster and number of members in each
uc, mc = unique(cls,return_counts=True)
# total number of unique cluster
ntot = len(uc)

print " cluster analysis"
print "   %d clusters in total " % (ntot)

# if nplot is not set, set it to total number of clusters
if nplot < 0: nplot = len(uc)

if smode == 1:
  # sort cluster according to cluster weights (fraction of densities)
  lnw = zeros(ntot)
  for i,c in enumerate(uc):
    lnw[i] = logsumexp(p[cls == c])-logsumexp(p)
  
  si = flipud(argsort(lnw))
  
  uc = uc[si]
 
  print " cluster / weight"
  w = exp(lnw[si])
  for i in range(nplot):
    print "   %d / %f" % (uc[i],w[i])
else:
    # sort cluster according to their size
    
  wtot = sum(wgrid)
  w = zeros(ntot)
  for i,c in enumerate(uc):
    w[i] = sum(wgrid[cls == c])/wtot

  si = flipud(argsort(w))
  
  uc = uc[si]
 
  print " cluster / weight"
  w = w[si]
  
  for i in range(nplot):
    print "   %d / %f" % (uc[i],w[i])

pc = uc[:nplot]

# show smallest (or lowest probable) cluster first
if flip: pc = flipud(pc)

# plot figures
fig, ax = P.subplots()
# create color array for clusters
cc=cm.rainbow(linspace(0,1,len(pc)))
random.shuffle(cc)

hullflag = True

if cvxflag:
  # print patches instead of scattered points
  patches = []
  for i,c in enumerate(pc):
    # data from single cluster
    x = X[c==cls,:]
    # estimate convex hull of cluster projection
    hull = ConvexHull(x)
    # plot cluster hull
#    P.plot(x[hull.vertices,0], x[hull.vertices,1], 'r--', lw=2)
    patch = Polygon(x[hull.vertices,:], True, color=cc[i], alpha=0.4)
    ax.add_patch(patch)
#  P.axis('equal')
  P.axis('off')  
else:
  # clusters smaller than minsize are printed in gray
  P.scatter(X[where(~in1d(cls, pc))[0],0],X[where(~in1d(cls, pc))[0],1],c='gray',edgecolor='None')
  # print all other cluster bigger than minsize
  for i,c in enumerate(pc):
    P.scatter(X[c==cls,0],X[c==cls,1],c=cc[i],edgecolor='None')
  # mark points with highest probability
  for i,c in enumerate(pc):
    P.scatter(X[(cls == c) & (p == max(p[cls == c])),0],X[(cls == c) & (p == max(p[cls == c])),1],edgecolor='k',color=cc[i])
#  P.axis('equal')
  P.axis('off')  

if pflag:
  P.figure()
  P.scatter(X[argsort(p),0],X[argsort(p),1],c=p[argsort(p)],edgecolor='None')
  P.colorbar()
  P.clim([lo,hi])
#  P.axis('equal')
  P.axis('off')
  
P.show()




























